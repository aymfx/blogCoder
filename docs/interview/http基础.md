---
title: http基础
---



## 1.说一下http 和 https

- http全称是超文本传输协议，https是带ssl的超文本传输协议，两个都是用于传输超文本到本地服务器的
- http传输的数据是不加密的，对于https来说它会在现在表示层搭建一个ssl通道，然后才能进行数据的交换，所以安全性比http高
- http端口是80，https端口是443
- http不需要购买证书，https需要购买且价格昂贵
- https链接时间长，并且耗电，消耗资源也多

## 2.常见的状态码有哪些



- 1xx：请求已接收，正在处理
- 2xx：处理成功

- - 204：请求被受理但是没有资源返回

- 3xx：重定向

- - 301：永久重定向
  - 302：临时重定向
  - 304：使用缓存
  - 307：临时重定向 强制使用 POST

- 4xx：客户端错误

- - 401：需要认证
  - 403：禁止访问
  - 404：未找到地址
  - 405：方法错误

- 5xx：服务端错误
  502：错误的网关
  503：服务器忙



## 3.http 请求方式有哪些



- get
- post
- put
- delete
- head
- options



## 4.http 请求报文和相应报文格式



请求报文



- 请求行 包含请求方法、URI、HTTP 版本信息
- 请求首部字段
- 请求体
- 空行



响应报文



- 状态行 包含 HTTP 版本、状态码、状态码的原因短语
- 相应首部字段
- 相应实体内容
- 空行



## 5.常见的 http 首部字段



请求首部字段



- Cache-control
- Content-type
- Cookie
- Host
- Origin
- Referer
- User-Agent
- Accept



相应首部字段



- Access-Control-Allow-Origin
- Cache-Control
- server
- Date
- Content-Type
- status



## 6.什么是 Http 协议无状态协议?



- http 无状态协议指的是在完成一次 http 请求之后，当下一次请求依然来自这个客户端，服务器是无法感知的。



## 7.怎么解决 Http 协议无状态协议?



- 通过设置 jwt 来设置获取通行证
- 通过设置 header 增加 token 字段来判断
- 采用 auth2 的协议，通过第三方进行校验识别



## 8.tcp 三次握手，一句话概括

客户端到服务器各自接受和发送，获得服务器资源需要经历三次握手，建立连接

- 客户端向服务端发送SYN包建立握手的请求
- 服务端接收到，并且返回ACK包和 SYN包
- 客户端接收到，并且返回带过来的ACK包，完成三次握手



## 9.四次挥手

- 主动断开的一方会发送一个FIN包，用来断开数据的传输
- 被动断开方，接收到FIN，它会回发一个ACK
- 被动断开方断开数据传输后，发送一个FIN给主动断开方
- 主动断开方接收FIN,然后发送ACK，完成四次挥手

  [三次握手四次挥手](https://zhuanlan.zhihu.com/p/86426969)

## 10.TCP 和 UDP 的区别

- tcp是面向连接的，udp是不需要建立连接直接可以通讯的
- tcp只能1：1，udp可以1：n
- tcp首部比较大20个字节，udp首部只有8个字节
- tcp传输可靠，udp传输不可靠
- TCP 是面向字节流，UDP 面向报文（网络出现拥塞不会使得发送速率降低）

## 11.什么是 WebSocket?

- 它是html5的协议，支持持久性连接
- 可以实现双向通讯
- 它是基于http协议的，在握手阶段是跟http相同的，实现握手的两个基本的属性是 upgrade connection



## 12.head和option请求方法作用

- head请求和get类似，只不过返回的响应没有具体的内容，用户可以获取报头
- option：试探连接 允许客户端查看服务器的性能，也可以查看服务器支持的请求方式等等



## 13.一个图片 url 访问后直接下载怎样实现?

- 请求的返回头里面，用于浏览器解析的重要的参数就是OSS的API文档中返回的http头部，决定了用户下载行为的参数

下载的情况下:

1. x-oss-object-type:
   Normal
2. x-oss-request-id:
   598D5ED34F29D01FE2925F41
3. x-oss-storage-class:
   Standard

## 14.说一下 http2.0

- 多路复用
- 压缩了首部
- 实现了服务端推动
- 采用了二进制编码，使得传输信息分成了更小的帧

## 15.补充 400 和 401、403 状态码

- 400产生的情况

- - 可能是请求的字段名称和字段类型没有和后端保持一致
  - 请求的方式不对
  - 请求的借口不存在

- 401 表示服务端需要认证
- 403 表示服务端拒绝访问

## 16.fetch 发送 2 次请求的原因

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功? 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的 请求。

## 17.http 常用请求头

| 协议头            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| Accept            | 可接受的响应内容类型(Content-Types)。                        |
| Accept-Charset    | 可接受的字符集                                               |
| Accept-Encoding   | 可接受的响应内容的编码方式。                                 |
| Accept-Language   | 可接受的响应内容语言列表。                                   |
| Accept-Datetime   | 可接受的按照时间来表示的响应内容版本                         |
| Authorization     | 用于表示 HTTP 协议中需要认证资源的认证信息                   |
| Connection        | 客户端(浏览器)想要优先使用的连接类型                         |
| Cache-Control     | 用来指定当前的请求/回复中的，是否使用缓存机制。              |
| Cookie            | 由之前服务器通过Set-Cooki(e 见下文)设置的一个HTTP协议Cookie  |
| Content-Length    | 以 8 进制表示的请求体的长度                                  |
| Content-MD5       | 请求体的内容的二进制 MD5 散列值(数字签名)，以 Base64 编 码的结果 |
| Content-Type      | 请求体的 MIME 类型 (用于 POST 和 PUT 请求中)                 |
| Date              | 发送该消息的日期和时间(以 RFC 7231 中定义的"HTTP 日期"格式 来发送) |
| Host              | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口 是对应的服务的标准端口(80)，则端口号可以省略 |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对 应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新 某个资源后，该资源未被修改的情况下，才更新该资源。 |
| If-Modified-Since | 允许在对应的资源未被修改的情况下返回 304 未修改              |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回 304 未修改( 304 Not Modified )，参考 超文本传输协议 的实体标记 |
| Origin            | 发起一个针对跨域资源共享的请求(该请求要求服务器在响应中加 入一个 Access-Control-Allow-Origin 的消息头，表示访问控制所允许 的来源)。 |
| Referer           | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接 将浏览器带到了当前页面。Referer 其实是 Referrer 这个单词，但 RFC 制作标准时给拼错了，后来也就将错就错使用 Referer 了。 |
| User-Agent        | 浏览器的身份标识字符串                                       |
| Upgrade           | 要求服务器升级到一个高版本协议。                             |
| Via               | 告诉服务器，这个请求是由哪些代理发出的。                     |



## 18.强，协商缓存

缓存分为两种:强缓存和协商缓存，根据响应的 header 内容来决定。

|          | 获取资源形式 | 状态码          | 发送请求到服务器                  |
| -------- | ------------ | --------------- | --------------------------------- |
| 强缓存   | 从缓存取     | 200(from cache) | 否，直接从缓存取                  |
| 协商缓存 | 从缓存取     | 304(not modify) | 是，通过服务器来告知缓存是否可 用 |

强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话， cache-control 的优先级高于 expires。

协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match

## 19.讲讲304

304:如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容(自 上次访问以来或者根据请求的条件)并没有改变，则服务器应当返回这个 304 状态码。

## 20.强缓存、协商缓存什么时候用哪个

![img](https://aymfx.github.io/pic/img/1620196742152-9aae2b6e-c600-483e-bfac-f3013fcbe8ae-20220805001724966.png)

## 21.GET 和 POST 的区别

get 参数通过 url 传递，post 放在 request body 中。

get 请求在 url 中传递的参数是有长度限制的，而 post 没有。

get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。 get 请求只能进行 url 编码，而 post 支持多种编码方式

get 请求会浏览器主动 cache，而 post 支持多种编码方式。

get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。

GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器 的限制，导致他们在应用过程中体现出一些不同。

GET 产生一个 TCP 数据包;POST 产生两个 TCP 数据包。

## 22.301 和 302 的区别

301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引 用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的。

302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的， 客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了 指定的情况下，这个响应才是可缓存的。

字面上的区别就是 301 是永久重定向，而 302 是临时重定向。 301比较常用的场景是使用域名跳转。302用来做临时跳转 比如未登陆的用户访问用户 中心重定向到登录页面。

# 23 常用的网站布局

![img](https://aymfx.github.io/pic/img/1620613957326-b3191ca6-cd44-449a-8007-9f37df49f84c.png)



