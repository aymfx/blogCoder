# 记录一些基础知识

## ts 常用的类型

js 本身的类型：boolean、 bigint、 null、number、 string、 symbol 和 undefined

ts 扩展类型（如下）

- any （允许任何类型）

```typescript
let a: any = 123;
a = '字符串';
```

- unknown （确保使用此类型的人声明类型是什么） 这个是 ts3.0 引入的，主要是为了避免使用 any，减少我们的开发负担

1、unknown 类型的值只能赋给 unknown 本身和 any 类型.使用过程必须将它转变成某种具体的类型才可以

```typescript
let a: unknown;
let b: string;
let c: unknown;
let d: any;
let e: number;

b = a; // 不能将类型“unknown”分配给类型“string”
c = a; // ok
d = a; // ok
e = a; // 不能将类型“unknown”分配给类型“number”
```

- never （这种类型不可能发生）

- void （返回 undefined 或没有返回值的函数）

## Function 类型

```typescript
type Person = {
  age: number;
  name: string;
};

function person(age: number, name: string): Person {
  return {
    age,
    name,
  };
}
```

## 对象类型

```typescript
type Person = {
  age: number;
  name: string;
};

const person: Person = {
  name: 'ly',
  age: 18,
};
```

## 可选参数

```typescript
type Person = {
  age?: number;
  name: string;
};

interface Person2 {
  age1: number;
  name2?: string;
}

const p1: Person = {
  name: 'ly',
};
const p2: Person2 = {
  age1: 19,
};
```

## 联合类型

联合类型可以通过分支判断来推断传入的值，判断的条件使用 typeof 或者 Array.isArray

```typescript
function getId(id: string | number) {
  //这就是联合类型
  if (typeof id === 'string') {
    id.toLocaleLowerCase();
  } else {
    console.log(id); // 数字不存在toLocaleLowerCase
  }
}

function getId(id: string[] | number) {
  if (Array.isArray(id)) {
    id.length; //数组长度
  } else {
    console.log(id); // 数字不存在toLocaleLowerCase
  }
}

// 如果是联合类型共同的属性 就可以不做判断
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3);
}
```

## 接口和类型别名

接口和类型别名大部分情况下没有区别，关键的区别在于不能重新开放类型添加新的属性

- 扩展属性

```typescript
// 接口扩展属性 通过 extends
interface Person {
  name: string;
}

interface Lau extends Person {
  age: number;
}

const liu: Lau = {
  age: 18,
  name: 'ly',
};

//类型别名扩展属性 通过&

type Person = {
  name: string;
};

type Lau = Person & {
  age: number;
};

const liu: Lau = {
  age: 18,
  name: 'ly',
};
```

- 添加新字段

```typescript
//interface
interface Person {
  name: string;
}

interface Person {
  age: number;
}

const liu: Person = {
  age: 18,
  name: 'ly',
};

//type  不允许重复定义
type Person = {
  name: string;
};

type Person = {
  //标识符“Person”重复
  age: number;
};

const liu: Person = {
  age: 18,
  name: 'ly',
};
```

## 类型推断 Type Assertions

两种方式

```typescript
const myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement;

const myCanvas = <HTMLCanvasElement>document.getElementById('main_canvas');

const x = 'hello' as unknown as number; //类型推断出string不能作为number 你需要先推断成unknow 再推断成number
```

## 字面量类型 Literal Types

我们可以定义一些常量类型，比如接受特定的枚举类型之类的

```typescript
type unionTypes = 'name' | 'age' | 'sex';

function getFild(param: unionTypes, value: string | number) {
  this.set(param, value);
}

getFild('person', 1); //类型“"person"”的参数不能赋给类型“unionTypes”的参数。
```

## as const

相当于 const 但是定义类型系统的 const 常用来把一些值变成字面量类型

```typescript
declare function handleRequest(url: string, method: 'GET' | 'POST'): void;

// const req = { url: "https://example.com", method: "GET" }  // 这样子去 会报错
// handleRequest(req.url, req.method); //类型“string”的参数不能赋给类型“"GET" | "POST"”的参数。

const req = { url: 'https://example.com', method: 'GET' } as const;
handleRequest(req.url, req.method);
```


