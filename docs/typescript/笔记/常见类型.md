---
title: ts 常用的类型 (Everyday Types)
date: 2020-10-01
group: 笔记
---

> js 本身的类型：boolean、 bigint、 null、number、 string、 symbol 和 undefined

## any （允许任何类型）

```typescript
let a: any = 123;
a = '字符串';
```

- unknown （确保使用此类型的人声明类型是什么） 这个是 ts3.0 引入的，主要是为了避免使用 any，减少我们的开发负担

1、unknown 类型的值只能赋给 unknown 本身和 any 类型.使用过程必须将它转变成某种具体的类型才可以

```typescript
let a: unknown;
let b: string;
let c: unknown;
let d: any;
let e: number;

b = a; // 不能将类型“unknown”分配给类型“string”
c = a; // ok
d = a; // ok
e = a; // 不能将类型“unknown”分配给类型“number”
```

## never （这种类型不可能发生）

## void （返回 undefined 或没有返回值的函数）

## Function 类型

```typescript
type Person = {
  age: number;
  name: string;
};

function person(age: number, name: string): Person {
  return {
    age,
    name,
  };
}
```

## 对象类型

```typescript
type Person = {
  age: number;
  name: string;
};

const person: Person = {
  name: 'ly',
  age: 18,
};
```

## 可选参数

```typescript
type Person = {
  age?: number;
  name: string;
};

interface Person2 {
  age1: number;
  name2?: string;
}

const p1: Person = {
  name: 'ly',
};
const p2: Person2 = {
  age1: 19,
};
```

## 联合类型

联合类型可以通过分支判断来推断传入的值，判断的条件使用 typeof 或者 Array.isArray

```typescript
function getId(id: string | number) {
  //这就是联合类型
  if (typeof id === 'string') {
    id.toLocaleLowerCase();
  } else {
    console.log(id); // 数字不存在toLocaleLowerCase
  }
}

function getId(id: string[] | number) {
  if (Array.isArray(id)) {
    id.length; //数组长度
  } else {
    console.log(id); // 数字不存在toLocaleLowerCase
  }
}

// 如果是联合类型共同的属性 就可以不做判断
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3);
}
```

## 接口和类型别名

接口和类型别名大部分情况下没有区别，关键的区别在于不能重新开放类型添加新的属性

- 扩展属性

```typescript
// 接口扩展属性 通过 extends
interface Person {
  name: string;
}

interface Lau extends Person {
  age: number;
}

const liu: Lau = {
  age: 18,
  name: 'ly',
};

//类型别名扩展属性 通过&

type Person = {
  name: string;
};

type Lau = Person & {
  age: number;
};

const liu: Lau = {
  age: 18,
  name: 'ly',
};
```

- 添加新字段

```typescript
//interface
interface Person {
  name: string;
}

interface Person {
  age: number;
}

const liu: Person = {
  age: 18,
  name: 'ly',
};

//type  不允许重复定义
type Person = {
  name: string;
};

type Person = {
  //标识符“Person”重复
  age: number;
};

const liu: Person = {
  age: 18,
  name: 'ly',
};
```

## 类型推断 Type Assertions

两种方式

```typescript
const myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement;

const myCanvas = <HTMLCanvasElement>document.getElementById('main_canvas');

const x = 'hello' as unknown as number; //类型推断出string不能作为number 你需要先推断成unknow 再推断成number
```

## 字面量类型 Literal Types

我们可以定义一些常量类型，比如接受特定的枚举类型之类的

```typescript
type unionTypes = 'name' | 'age' | 'sex';

function getFild(param: unionTypes, value: string | number) {
  this.set(param, value);
}

getFild('person', 1); //类型“"person"”的参数不能赋给类型“unionTypes”的参数。
```

## as const

相当于 const 但是定义类型系统的 const 常用来把一些值变成字面量类型

```typescript
declare function handleRequest(url: string, method: 'GET' | 'POST'): void;

// const req = { url: "https://example.com", method: "GET" }  // 这样子去 会报错
// handleRequest(req.url, req.method); //类型“string”的参数不能赋给类型“"GET" | "POST"”的参数。

const req = { url: 'https://example.com', method: 'GET' } as const; // 表示将整个对象转换成一个类型字面量
handleRequest(req.url, req.method);
```

## null 和 undefined

ts 也有两个这样的同名的类型，他们的行为取决于是否开启了 strictNullChecks,strictNullChecks 开启后在使用这个变量之前需要先校验这些值是不是 null 或者 undefined

```typescript
function getName(name: string | null): string {
  if (name === null) {
    //需要先校验是不是空
    return '';
  }
  return name.toString();
}

function getName2(name: string | null): string {
  return name!.toString(); // 非空断言操作符（后缀 !） （Non-null Assertion Operator）
}
```

## 枚举类型 （Enums）

```typescript
enum memberTypes {
  low = '普通会员',
  high = '高级会员',
}
console.log(memberTypes.low);
console.log(memberTypes['high']);
```

```typescript
enum Direction {
  Up = 1,
  Down,
  Left,
  Right,
}
```

## 不常见的原始类型（Less Common Primitives）

ES2020 引入原始类型 BigInt，用于表示非常大的整数：

```typescript
const bigNumber: bigint = BigInt(100);
const bigNumber2: bigint = 250n;
```

## Symbol 类型

这也是 JavaScript 中的一个原始类型，通过函数 Symbol()，我们可以创建一个全局唯一的引用：

```typescript
const first: symbol = Symbol('first');
const first2: symbol = Symbol('first2');
console.log(first === first2);
```
